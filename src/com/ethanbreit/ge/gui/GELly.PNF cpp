#include <ge/gui/GELly.h>
 
namespace ge
{
		GELlyContext* createContext()
		{
			GELlyContext* ctx = new GELlyContext();
			{
				/*Shader vert = new Shader(Resources.get("GELly/GELly.glsl").asString(), GL20.GL_VERTEX_SHADER, new std::string[]{ "VERTEX" });
				Shader frag = new Shader(Resources.get("GELly/GELly.glsl").asString(), GL20.GL_FRAGMENT_SHADER, new std::string[]{ "FRAGMENT" });

				ctx.mesh = new Mesh(new Program(new Shader[]{ frag, vert }),
					new VertexBuffer[]{ Quad.genVertVertexBuffer() }, Quad.genIndexBuffer());*/
			}
			//ctx.listener = ScreenInput.addListener((e)->screenListener(ctx, e));
			ctx->mesh->setTexture(FONT_ATLAS_POS, ctx.style.font.atlas);

			return ctx;
		}
		void destroyContext(GELlyContext* ctx)
		{
			ctx.mesh.deepDestroy();
			ctx.style.font.atlas.destroy();
		}

		void startRender(GELlyContext* ctx)
		{
			glEnable(GL30.GL_BLEND); //Don't use actual opengl calls
			glBlendFunc(GL30.GL_SRC_ALPHA, GL30.GL_ONE_MINUS_SRC_ALPHA); //TODO: do better and not as bad

			processEventInteractions(ctx);

			for (Map.Entry<std::string, GELlyContext._window> win : ctx.windows.entrySet())
			{
				for (Map.Entry<std::string, GELlyContext._component> cmp : win.getValue().components.entrySet())
				{
					cmp.getValue().hasDrewn = false;
				}
				win.getValue().hasDrewn = false;
			}

			//Write to separate FBO
			ctx.isRendering = true;
		}

		void stopRender(GELlyContext ctx)
		{
			//Write to separate FBO
			{
				LinkedList<std::string> winsToRemove = new LinkedList<>();

				for (Map.Entry<std::string, GELlyContext._window> win : ctx.windows.entrySet())
				{
					LinkedList<std::string> cmpsToRemove = new LinkedList<>();

					for (Map.Entry<std::string, GELlyContext._component> cmp : win.getValue().components.entrySet())
					{
						if (!cmp.getValue().hasDrewn)
						{
							cmp.getValue().destroy();
							cmpsToRemove.add(cmp.getKey());
						}
					}

					for (std::string cmp : cmpsToRemove)
						win.getValue().components.remove(cmp);

					if (!win.getValue().hasDrewn) //Destroy the window if it hasn't been drawn in the most recent update
						winsToRemove.add(win.getKey());
				}
				for (std::string s : winsToRemove)
				{
					ctx.windows.get(s).destroy();
					ctx.windows.remove(s);
				}

			}


			ctx.isRendering = true;
		}

		/**
		* %Window
		*/

		void startWindow(GELlyContext ctx, std::string label, int x, int y, int width, int height, long flags)
		{
			if (ctx.inWindow)
			{
				Log.err(LOG_TAG, "Attempt to start new window while already in one");
				return;
			}
			if (!ctx.windows.containsKey(label))
			{
				GELlyContext._window win = new GELlyContext._window();

				win.label = label;

				ctx.windows.put(label, win);

			}
			ctx.currentWindow = ctx.windows.get(label);

			ctx.inWindow = true;
			ctx.currentWindow.flags = flags;

			if (!ctx.currentWindow.hasInit)
			{
				ctx.currentWindow.hasInit = true;
				ctx.currentWindow.ctx = ctx;

				if (ctx.currentWindow.pos == null)
					ctx.currentWindow.pos = translateDimensionsScreenspace(new Vector2i(x, y));
				if (ctx.currentWindow.dim == null)
					ctx.currentWindow.dim = translateDimensions(new Vector2i(width, height));

				if (!flagCheck(ctx.currentWindow.flags, GELLY_WINDOW_NO_TITLE))
				{
					ctx.currentWindow.label_i = genLabelIntractable(ctx, ctx.currentWindow);
					ctx.interactables.add(ctx.currentWindow.label_i);
				}
				if (!flagCheck(ctx.currentWindow.flags, GELLY_WINDOW_NOT_RESIZABLE))
				{
					ctx.currentWindow.resize_i = genResizeIntractable(ctx, ctx.currentWindow);
					ctx.interactables.add(ctx.currentWindow.resize_i);
				}
			}
			ctx.currentWindow.elementY = ctx.style.WINDOW_ELEMENT_PADDING + (flagCheck(ctx.currentWindow.flags, GELLY_WINDOW_NO_TITLE) ? 0 : ctx.style.WINDOW_TITLE_HEIGHT);

			renderWindow(ctx, ctx.currentWindow);

		}

		void endWindow(GELlyContext ctx)
		{
			if (!ctx.inWindow)
			{
				Log.err(LOG_TAG, "Attempt to end new window without starting one");
				return;
			}


			ctx.currentWindow.hasDrewn = true;

			ctx.inWindow = false;
		}

		/**
		* %COMPONENTS
		*/

		void drawLabel(GELlyContext ctx, std::string text)//Add more params TODO: Finish
		{
			float labelHeight = translateDimensionHeight(ctx.style.LABEL_HEIGHT);

			Vector2f pos = new Vector2f(ctx.currentWindow.pos.x, ctx.currentWindow.pos.y - translateDimensionHeight(ctx.currentWindow.elementY + ctx.style.LABEL_HEIGHT));
			Vector2f dim = new Vector2f(ctx.currentWindow.dim.x, labelHeight);

			if (translateDimensionHeight(ctx.currentWindow.elementY + ctx.style.LABEL_HEIGHT) > ctx.currentWindow.dim.y)
				return;

			renderString(ctx, text, pos, dim, ctx.currentWindow.depthPos - 0.01f, ctx.style.WINDOW_TITLE_TEXT);

			ctx.currentWindow.elementY += ctx.style.LABEL_HEIGHT + ctx.style.WINDOW_ELEMENT_PADDING;
		}

		bool drawButton(GELlyContext* ctx, std::string label, glm::vec3 colour)
		{

			float labelHeight = translateDimensionHeight(ctx.style.LABEL_HEIGHT);

			Vector2f pos = new Vector2f(ctx.currentWindow.pos.x, ctx.currentWindow.pos.y - translateDimensionHeight(ctx.currentWindow.elementY + ctx.style.LABEL_HEIGHT));
			Vector2f dim = new Vector2f(ctx.currentWindow.dim.x, labelHeight);



			GELlyContext._button thisC;
			if (!ctx.currentWindow.components.containsKey(label))
			{
				thisC = new GELlyContext._button();
				ctx.currentWindow.components.put(label, thisC);
				thisC.label = label;
				thisC.intractable = new GELlyContext._intractable();
				thisC.ctx = ctx;
				thisC.intractable.interactionListiner = (e) -> {
					if (e == ScreenInput.EventType.DOWN)
						thisC.hasBeenClicked = true;
				};
				ctx.interactables.add(thisC.intractable);
			}
			else
				thisC = (GELlyContext._button) ctx.currentWindow.components.get(label);

			if (translateDimensionHeight(ctx.currentWindow.elementY + ctx.style.LABEL_HEIGHT) > ctx.currentWindow.dim.y)
			{
				thisC.destroy();
				return false;
			}

			thisC.hasDrewn = true;
			thisC.intractable.aabb = new AABB(new Vector2f(pos.x + (dim.x / 2), pos.y + (dim.y / 2)), new Vector2f(dim.x / 2, dim.y / 2));


			renderBox(ctx, pos, dim, ctx.currentWindow.depthPos - 0.01f, ctx.style.WINDOW_BUTTON_TOGGLE_BG);
			renderString(ctx, label, pos, dim, ctx.currentWindow.depthPos - 0.02f, ctx.style.WINDOW_HIGHLIGHT_2);

			ctx.currentWindow.elementY += ctx.style.LABEL_HEIGHT + ctx.style.WINDOW_ELEMENT_PADDING;

			if (thisC.hasBeenClicked)
			{
				thisC.hasBeenClicked = false;
				return true;
			}
			return false;
		}


		bool drawToggleButton(GELlyContext* ctx, std::string label)
		{

			float labelHeight = translateDimensionHeight(ctx.style.LABEL_HEIGHT);

			Vector2f pos = new Vector2f(ctx.currentWindow.pos.x, ctx.currentWindow.pos.y - translateDimensionHeight(ctx.currentWindow.elementY + ctx.style.LABEL_HEIGHT));
			Vector2f dim = new Vector2f(ctx.currentWindow.dim.x, labelHeight);


			if (translateDimensionHeight(ctx.currentWindow.elementY + ctx.style.LABEL_HEIGHT) > ctx.currentWindow.dim.y)
				return false;


			GELlyContext._toggle_button thisC;
			if (!ctx.currentWindow.components.containsKey(label))
			{
				Log.dbg("button created");
				thisC = new GELlyContext._toggle_button();
				ctx.currentWindow.components.put(label, thisC);
				thisC.ctx = ctx;
				thisC.label = label;
				thisC.intractable = new GELlyContext._intractable();
				thisC.intractable.interactionListiner = (e) -> {
					if (e == ScreenInput.EventType.DOWN)
						thisC.clickState = !thisC.clickState;
				};
				ctx.interactables.add(thisC.intractable);
			}
			else
				thisC = (GELlyContext._toggle_button) ctx.currentWindow.components.get(label);

			thisC.hasDrewn = true;
			thisC.intractable.aabb = new AABB(new Vector2f(pos.x + (dim.x / 2), pos.y + (dim.y / 2)), new Vector2f(dim.x / 2, dim.y / 2));


			renderBox(ctx, pos, dim, ctx.currentWindow.depthPos - 0.01f, ctx.style.WINDOW_BUTTON_TOGGLE_BG);
			renderString(ctx, label, pos, dim, ctx.currentWindow.depthPos - 0.02f, thisC.clickState ? ctx.style.WINDOW_HIGHLIGHT : ctx.style.WINDOW_BODY_TEXT);

			ctx.currentWindow.elementY += ctx.style.LABEL_HEIGHT + ctx.style.WINDOW_ELEMENT_PADDING;

			return thisC.clickState;
		}


		/**
		*
		* %Listener
		*
		*/
		
		void screenListener(GELlyContext ctx, ScreenInput.EventType event)
		{

			if (event == ScreenInput.EventType.MOVE ||
				ScreenInput.getXScr() < 0 || ScreenInput.getYScr() < 0 ||
				ScreenInput.getXScr() > Renderer.getWIDTH() || ScreenInput.getYScr() > Renderer.getHEIGHT())
				return;
			GELlyContext._intractable intractable = null;
			for (GELlyContext._intractable i : ctx.interactables)
			{
				if (i.aabb.inside(ScreenInput.getPosGL()))
				{
					if (intractable == null)
					{
						intractable = i;
						continue;
					}
					if (intractable.depth < i.depth)
						intractable = i;
				}
			}
			if (intractable != null)
				ctx.eventInteractionBuffer.add(new ImmutablePair<>(intractable, event));
		}



		/**
		*
		* %UTIL
		*
		*/

		private static Vector2f aspectRatioify(Vector2f inDim)
		{
			if (Renderer.getWIDTH() > Renderer.getHEIGHT())
			{
				float ratio = (float)Renderer.getWIDTH() / Renderer.getHEIGHT();
				return new Vector2f(inDim.x, inDim.y * ratio);
			}
			else
			{
				float ratio = (float)Renderer.getHEIGHT() / Renderer.getWIDTH();
				return new Vector2f(inDim.x*ratio, inDim.y);
			}
		}

		private static Vector2f translateDimensions(Vector2i inDim)
		{
			Vector2f outDim = new Vector2f();

			outDim.x = ((float)inDim.x) / (Renderer.getWIDTH() / 2);
			outDim.y = ((float)inDim.y) / (Renderer.getHEIGHT() / 2);


			return outDim;
		}

		private static float translateDimensionHeight(float inDim)
		{
			return (inDim) / (Renderer.getHEIGHT() / 2);
		}

		private static float translateDimensionWidth(float inDim)
		{
			return (inDim) / (Renderer.getWIDTH() / 2);
		}


		private static Vector2f translateDimensionsScreenspace(Vector2i inDim)
		{
			Vector2f outDim = new Vector2f();

			outDim.x = ((float)inDim.x) / (Renderer.getWIDTH() / 2) - 1;
			outDim.y = ((float)inDim.y*-1f) / (Renderer.getHEIGHT() / 2) + 1;

			return outDim;
		}

		private static boolean flagCheck(long flags, long flag)
		{
			return (flags & flag) > 0;
		}

		/**
		*
		* %RENDERING
		*
		*/

		public static void renderBox(GELlyContext ctx, Vector2f pos, Vector2f dim, float depth, Colour colour) //TODO: add drawBox as a wrapper for this.
		{
			ctx.mesh.setUniform(U_MODE, MODE_RECT);
			ctx.mesh.setUniform(U_POS, pos);
			ctx.mesh.setUniform(U_DIM, dim);
			ctx.mesh.setUniform(U_DEPTH, depth);
			ctx.mesh.setUniform(U_BG_Colour, colour.getVec4());

			ctx.mesh.render();
		}

		private static void renderString(GELlyContext ctx, std::string str, Vector2f pos, Vector2f bounds, float depth, Colour colour) //TODO: Better Scaling to Bounds.
		{
			Vector2f fBound = new Vector2f(ctx.style.font.boundingWidth, ctx.style.font.boundingHeight);
			fBound = aspectRatioify(fBound);
			fBound.normalize();

			boolean widthBiggest = fBound.x*str.length() > fBound.y; //should almost always be true

																   //float scale = widthBiggest ? fBound.x*bounds.x : fBound.y*bounds.y; //fix to scale with long strings (does not check if string height exceeds bounds) -- doesn't work
			float scale = bounds.y; //test
			fBound.mul(scale);


			if (fBound.x > bounds.x || fBound.y > bounds.y)
				Log.err(LOG_TAG, "std::string exceeds bounds (Not finished function). Font bounds: " + fBound.toString(NumberFormat.getNumberInstance()) + ", Allocated Area: " + bounds.toString(NumberFormat.getNumberInstance()) + ", Scale: " + std::string.valueOf(bounds.y));

			for (int i = 0; i < str.length(); i++)
			{
				if (((i + 1)*fBound.x) > bounds.x)
					continue;
				ctx.mesh.setUniform(U_MODE, MODE_TEXT);
				ctx.mesh.setUniform(U_POS, new Vector2f(pos.x + (i*fBound.x), pos.y));
				ctx.mesh.setUniform(U_DIM, fBound);
				ctx.mesh.setUniform(U_DEPTH, depth);
				ctx.mesh.setUniform(U_FG_Colour, colour.getVec4());
				ctx.mesh.setUniform(U_ATLAS, FONT_ATLAS_POS);
				ctx.mesh.setUniform(U_ATLAS_LOC, ctx.style.font.getAtlasDim(str.charAt(i)));
				ctx.mesh.render();
			}

		}

		private static void renderWindow(GELlyContext ctx, GELlyContext._window window)
		{
			Vector2f pos = new Vector2f(window.pos.x, window.pos.y - window.dim.y);
			if (!flagCheck(window.flags, GELLY_WINDOW_NO_TITLE))
			{
				Vector2f dim = new Vector2f(window.dim);
				dim.y = translateDimensionHeight(ctx.style.WINDOW_TITLE_HEIGHT);

				Vector2f tPos = new Vector2f(pos.x, pos.y + (window.dim.y - dim.y));

				ctx.mesh.setUniform(U_MODE, MODE_RECT);
				ctx.mesh.setUniform(U_POS, tPos);
				ctx.mesh.setUniform(U_DIM, dim);
				ctx.mesh.setUniform(U_BG_Colour, ctx.style.WINDOW_HIGHLIGHT.getVec4());
				ctx.mesh.setUniform(U_DEPTH, window.depthPos - 0.01f);

				ctx.mesh.render();

				window.label_i.aabb = genLabelAABB(ctx, window);

				//text
				renderString(ctx, window.label, tPos, dim, window.depthPos - 0.02f, ctx.style.WINDOW_TITLE_TEXT);

			}

			if (!flagCheck(window.flags, GELLY_WINDOW_NOT_RESIZABLE))
			{

				Vector2f dim = new Vector2f(window.dim);

				dim.x = translateDimensionWidth(ctx.style.WINDOW_RESIZE_PAD_DIM);
				dim.y = translateDimensionHeight(ctx.style.WINDOW_RESIZE_PAD_DIM);

				Vector2f rPos = new Vector2f(pos.x + (window.dim.x - dim.x), pos.y);

				ctx.mesh.setUniform(U_MODE, MODE_RECT);
				ctx.mesh.setUniform(U_POS, rPos);
				ctx.mesh.setUniform(U_DIM, dim);

				ctx.mesh.setUniform(U_BG_Colour, ctx.style.WINDOW_HIGHLIGHT_2.getVec4());

				ctx.mesh.setUniform(U_DEPTH, window.depthPos - 0.02f);

				window.resize_i.aabb = genResizeAABB(ctx, window);

				ctx.mesh.render();
			}

			if (!flagCheck(window.flags, GELLY_WINDOW_NO_BACKGROUND))
			{
				ctx.mesh.setUniform(U_MODE, MODE_RECT);
				ctx.mesh.setUniform(U_POS, pos);
				ctx.mesh.setUniform(U_DIM, window.dim);

				ctx.mesh.setUniform(U_BG_Colour, ctx.style.WINDOW_BACKGROUND.getVec4());

				ctx.mesh.setUniform(U_DEPTH, window.depthPos);

				ctx.mesh.render();
			}


		}

		/**
		* %Bounding
		*/
		//Resize
		private static GELlyContext._intractable genResizeIntractable(GELlyContext ctx, GELlyContext._window win)
		{
			GELlyContext._intractable e = new GELlyContext._intractable();
			e.aabb = genResizeAABB(ctx, win);
			e.depth = win.depthPos;
			e.interactionListiner = (et) ->
			{
				if (et == ScreenInput.EventType.DOWN)
				{
					win.dim.set(new Vector2f(ScreenInput.getXGL() - win.pos.x, win.pos.y - ScreenInput.getYGL()));
					ScreenInput.addListener(e.eventlistiner);
				}
			};
			e.eventlistiner = (et) ->
			{
				if (et == ScreenInput.EventType.MOVE)
				{
					Vector2f newDim = new Vector2f(ScreenInput.getXGL() - win.pos.x, win.pos.y - ScreenInput.getYGL());
					if (newDim.x < translateDimensionWidth(ctx.style.WINDOW_MINIMUM_SIZE.x))
						newDim.x = translateDimensionWidth(ctx.style.WINDOW_MINIMUM_SIZE.x);
					if (newDim.y < translateDimensionHeight(ctx.style.WINDOW_MINIMUM_SIZE.y))
						newDim.y = translateDimensionHeight(ctx.style.WINDOW_MINIMUM_SIZE.y);
					win.dim.set(newDim);
				}

				else if (et == ScreenInput.EventType.UP)
					ScreenInput.removeListener(e.eventlistiner);
			};
			return e;
		}
		private static AABB genResizeAABB(GELlyContext ctx, GELlyContext._window win)
		{
			return new AABB(new Vector2f(
				win.pos.x + win.dim.x - (translateDimensionWidth(ctx.style.WINDOW_RESIZE_PAD_DIM) / 2),
				win.pos.y - win.dim.y + (translateDimensionHeight(ctx.style.WINDOW_RESIZE_PAD_DIM) / 2)),
				new Vector2f(translateDimensionWidth(ctx.style.WINDOW_RESIZE_PAD_DIM) / 2, translateDimensionHeight(ctx.style.WINDOW_RESIZE_PAD_DIM) / 2));
		}

		//Label
		private static GELlyContext._intractable genLabelIntractable(GELlyContext ctx, GELlyContext._window win)
		{
			GELlyContext._intractable e = new GELlyContext._intractable();
			e.aabb = genLabelAABB(ctx, win);
			e.depth = win.depthPos;
			e.interactionListiner = (et) ->
			{
				if (et == ScreenInput.EventType.DOWN)
				{
					win.pos.set(ScreenInput.getPosGL());
					ScreenInput.addListener(e.eventlistiner);
				}
			};
			e.eventlistiner = (et) ->
			{
				if (et == ScreenInput.EventType.MOVE)
					win.pos.set(ScreenInput.getPosGL());
				else if (et == ScreenInput.EventType.UP)
					ScreenInput.removeListener(e.eventlistiner);
			};
			return e;
		}

		private static AABB genLabelAABB(GELlyContext ctx, GELlyContext._window win)
		{
			return new AABB(new Vector2f(win.pos.x + (win.dim.x / 2), win.pos.y - (translateDimensionHeight(ctx.style.LABEL_HEIGHT) / 2)),
				new Vector2f(win.dim.x / 2, translateDimensionHeight(ctx.style.LABEL_HEIGHT) / 2));
		}


		private static void processEventInteractions(GELlyContext ctx)
		{
			while (!ctx.eventInteractionBuffer.isEmpty())
			{
				ImmutablePair<GELlyContext._intractable, ScreenInput.EventType> interaction = ctx.eventInteractionBuffer.poll();
				interaction.left.interactionListiner.accept(interaction.right);
			}
		}
	}
}